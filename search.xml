<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue中使用leaflet-side-by-side插件作拉帘对比</title>
    <url>/2019/11/05/leafletSidebySideDemo/</url>
    <content><![CDATA[<p>在上一篇<a href="https://aarontalk.com/2019/11/04/LeafletWithVue/">Vue中使用Leaflet加载地图</a> 中我们已经完成了地图的创建和tileLayer的加载，也给出了加载Open Street Map开源地图的Leaflet example，这里紧接上文，咱们来学习一下Leaflet中一个非常实用的插件——Leaflet-side-by-side。</p>
<a id="more"></a>

<p>这个插件是干嘛的呢，单看名字应该也能猜个差不多，先看看Leafletjs官网给出的简介吧：</p>
<blockquote>
<p> A Leaflet control to add a split screen to compare two map overlays.</p>
</blockquote>
<p>很明显，这是一个分屏控件，能够把地图一分为二，对比左右两边的图层。如果一时想象不出它是什么样的也没关系，这里有个插件作者给出的 <a href="http://lab.digital-democracy.org/leaflet-side-by-side/" target="_blank" rel="noopener">Demo</a> 可以让你一目了然。作者给出的使用方法除了引入必要的js文件外，总共分三步：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myLayer1 = L.tileLayer(...).addTo(map);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myLayer2 = L.tileLayer(...).addTo(map)</span><br><span class="line"></span><br><span class="line">L.control.sideBySide(myLayer1, myLayer2).addTo(map);</span><br></pre></td></tr></table></figure>

<p>这样就可以啦？我一开始也是将信将疑的。但是看了上面Demo的源码之后发现，嘿！还真是！但是在vue中实际使用的时候还是碰到点小坑的，当然坑不是在它这，而是在上一篇中曾提到的map.js中创建瓦片图层的部分：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建瓦片图层</span></span><br><span class="line"><span class="keyword">const</span> createTileLayer = <span class="function">(<span class="params">map, url, options</span>) =&gt;</span> &#123; </span><br><span class="line">    <span class="keyword">let</span> tileLayer = L.tileLayer(url, options)</span><br><span class="line">    tileLayer.addTo(map)</span><br><span class="line">    <span class="keyword">return</span> tileLayer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来Google出来的教程中给的是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建瓦片图层</span></span><br><span class="line"><span class="keyword">const</span> createTileLayer = <span class="keyword">async</span> (map, url, options) =&gt; &#123; </span><br><span class="line">    <span class="keyword">let</span> tileLayer = L.tileLayer(url, options)</span><br><span class="line">    tileLayer.addTo(map)</span><br><span class="line">    <span class="keyword">return</span> tileLayer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>差别就在于async这里。因为leaflet中创建图层的方法是异步方法，所以原教程作者使用了async来处理异步的问题，但实际尝试发现，不仅没啥区别，而且造成使用Leaflet-side-by-side插件时，左右两边的图始终是重叠加载的（即上面一个图层，下面一个图层），死活实现不了分窗口拉帘对比的效果。查了半天想起来可能是这里的问题，果然把async直接去掉后瞬间舒适了……</p>
<p>好，废话再不多说，Leaflet-side-by-side插件demo开搞。</p>
<p>首先，肯定是nmp或者在Vue GUI中去安装leaflet-side-by-side：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install leaflet-side-by-side --save</span><br></pre></td></tr></table></figure>

<p>咱们直接把上一篇中的Code拿过来继续使用。既然是Leaflet的插件，那么上一篇也说过了，最好是把地图相关的交互都放到一个地方，这样便于后期代码的维护，有点强迫症的也会觉得更舒适一些。所以咱们自然是继续在map.js中添加相应的函数声明，添加完后utils/map.js应该像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'leaflet/dist/leaflet.css'</span></span><br><span class="line"><span class="keyword">import</span> L <span class="keyword">from</span> <span class="string">'leaflet'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'leaflet-side-by-side'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建地图</span></span><br><span class="line"><span class="keyword">const</span> createMap = <span class="function">(<span class="params">divId, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = L.map(divId, options)</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建瓦片图层</span></span><br><span class="line"><span class="keyword">const</span> createTileLayer = <span class="function">(<span class="params">map, url, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tileLayer = L.tileLayer(url, options)</span><br><span class="line">    tileLayer.addTo(map)</span><br><span class="line">    <span class="keyword">return</span> tileLayer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里就是为Leaflet-side-by-side新添加的创建compare-side-by-side函数</span></span><br><span class="line"><span class="comment">//注意要在前面先import leaflet-side-by-side</span></span><br><span class="line"><span class="keyword">const</span> compareSBS = <span class="function">(<span class="params">mapLayer1, mapLayer2, map, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> compareLayer = L.control.sideBySide(mapLayer1, mapLayer2, options)</span><br><span class="line">    compareLayer.addTo(map)</span><br><span class="line">    <span class="keyword">return</span> compareLayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    createMap,</span><br><span class="line">    createTileLayer,</span><br><span class="line">    compareSBS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以在Map.vue中使用compareSBS来做分窗口拉帘对比啦。更改后的Map.vue长这样子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"map-container"</span> id=<span class="string">"map-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "mapView",</span></span><br><span class="line"><span class="regexp">  components: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      map: null,</span></span><br><span class="line"><span class="regexp">      leftLayer: null,</span></span><br><span class="line"><span class="regexp">      rightLayer: null,</span></span><br><span class="line"><span class="regexp">      mapBoxURL: </span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/为了对比我这里用了mapbox的地图服务，需要相应的accesstoken，</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/可以去申请一下，对于开发的需求来说几乎等于免费。当然你直接用同一个图来尝试也没问题。</span></span><br><span class="line"><span class="regexp">        "https:/</span><span class="regexp">/api.mapbox.com/</span>styles/v1/aaron-mapbox/ck2e1s63x0lhh1clj4nje8a14/tiles/<span class="number">256</span>/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;?access_token=yourtoken<span class="string">", </span></span><br><span class="line"><span class="string">      OSMUrl: "</span>https:<span class="comment">//&#123;s&#125;.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">      <span class="comment">//创建地图</span></span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">this</span>.$utils.map.createMap(<span class="string">"map-container"</span>);</span><br><span class="line">    <span class="comment">// 设施地图视图 中心位置，随便选，可以直接搜你感兴趣的位置经纬度即可，13代表默认瓦片图层等级</span></span><br><span class="line">    <span class="keyword">this</span>.map.setView([<span class="number">34.03</span>, <span class="number">-118.15</span>], <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载 open street map和mapbox 图层服务</span></span><br><span class="line">    <span class="keyword">this</span>.leftLayer = <span class="keyword">this</span>.$utils.map.createTileLayer(<span class="keyword">this</span>.map, <span class="keyword">this</span>.OSMUrl, &#123;<span class="attr">maxZoom</span>: <span class="number">19</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.rightLayer = <span class="keyword">this</span>.$utils.map.createTileLayer(</span><br><span class="line">      <span class="keyword">this</span>.map,</span><br><span class="line">      <span class="keyword">this</span>.mapBoxURL,</span><br><span class="line">      &#123;<span class="attr">maxZoom</span>: <span class="number">19</span>&#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// side by side 对比</span></span><br><span class="line">    <span class="keyword">this</span>.$utils.map.compareSBS(<span class="keyword">this</span>.leftLayer, <span class="keyword">this</span>.rightLayer, <span class="keyword">this</span>.map, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style lang="less"&gt;</span></span><br><span class="line"><span class="regexp">.map-container &#123;</span></span><br><span class="line"><span class="regexp">  position: absolute;</span></span><br><span class="line"><span class="regexp">  left: 0;</span></span><br><span class="line"><span class="regexp">  top: 100px;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  height: 100%;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，跟插件作者给出的方法类似，也是分别加载两个图层，然后把图层丢到L.control控件里就完事了。方便、高效，实际使用也算比较美观。</p>
<p><img src="/2019/11/05/leafletSidebySideDemo/image-20191105203115464.png" alt="image-20191105203115464"></p>
<p>好啦，以上就是今天的全部内容，有不清楚的或者遇到相关问题的，欢迎评论或私信联系，大家相互学习。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>leaflet</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 中使用 Leaflet 加载地图</title>
    <url>/2019/11/04/LeafletWithVue/</url>
    <content><![CDATA[<p>Leaflet是地图开发中常用的一个开源Javascript库，不仅对于移动设备有所适配，而且在满足常见的地图开发需求的同时做到了非常小的体量（仅38KB）。</p>
<p>虽然Leaflet的设计理念是简约、性能和可用性优先，没有那些花里胡哨的功能，但是丰富的开源插件同样可以让你在地图应用开发过程中优雅地避免重复造轮子的过程。</p>
<p>另外，作为一个刚学Vue不久的小菜鸟，自然在面对一些小需求的时候想用来练练手，借着给公司做个遥感影像数据的Web展示页面的机会，摸索了一下在Vue中如何使用Leaflet，下面就做个简单的梳理和记录。</p>
<a id="more"></a>

<p>首先，新建一个Vue项目，现在比较喜欢用Vue CLI的图形界面，过程可视化且流程简单，而且项目管理非常方便，这里也不在赘述了。需要注意的是由于Leaflet和其它相关插件采用的是Less，所以选择css-preloader时建议选择Less。</p>
<p>接下来就是安装Leaflet。可以直接在Vue CLI中通过install dependencies搜索安装（推荐），也可以直接用命令行安装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install leaflet --save</span><br></pre></td></tr></table></figure>

<p>安装完成后就可以开始接下来的具体码代码工作了。我个人比较喜欢把这种相对独立的通用功能的JS文件放到一个独立的文件夹里，便于后期的代码维护。所以在vue项目的src目录下新建utils文件夹作为存放这些JS文件的工具箱。然后在utils文件夹下新建map.js和index.js。现在的基本目录应该类似这面这样：</p>
<img src="/2019/11/04/LeafletWithVue/微信截图_20191104102134.png" alt="微信截图_20191104102134" style="zoom:80%;">

<p>文件准备齐了，接着咱们来看看文件里都应该写些什么。</p>
<p>map.js中自然应该是leaflet的相关代码，第一步，import相关文件和模块并声明创建地图的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/utils/map.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'leaflet/dist/leaflet.css'</span></span><br><span class="line"><span class="keyword">import</span> L <span class="keyword">from</span> <span class="string">'leaflet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMap = <span class="function">(<span class="params">divId, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = L.map(divId, options)</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    createMap,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数写好了，还需要给它一个出口，即在src/utils/index.js中作export：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/utils/index.js</span></span><br><span class="line"><span class="keyword">import</span> map <span class="keyword">from</span> <span class="string">"./map"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  map</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了让Vue能够直接调用，需要在main.js中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">'./utils'</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$utils = utils</span><br></pre></td></tr></table></figure>

<p>接下来就可以愉快地编写view了，views文件夹下新建Map.vue</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//views/Map.vue</span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"map-container"</span> id=<span class="string">"map-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "mapView",</span></span><br><span class="line"><span class="regexp">  components: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      map: null,      </span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;</span></span><br><span class="line"><span class="regexp">    this.map = this.$utils.map.createMap("map-container");</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style lang=<span class="string">"less"</span>&gt;</span><br><span class="line">.map-container &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: <span class="number">0</span>;</span><br><span class="line">  top: <span class="number">0</span>;</span><br><span class="line">  width: <span class="number">100</span>%;</span><br><span class="line">  height: <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样一来，Map.vue就可以作为模块在其它文件中引用了。（注：因为我在Vue项目新建的过程中选择了vue-router，所以下面的举例是在Vue默认创建的页面路由中添加了map的入口）</p>
<p>比如，在App.vue中添加map入口：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//src/app.vue</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> |</span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/map"</span>&gt;</span>Map<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后/routers/index.js中添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Map</span> <span class="keyword">from</span> <span class="string">'../views/Map.vue'</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    name: <span class="string">'about'</span>,</span><br><span class="line">    <span class="comment">// route level code-splitting</span></span><br><span class="line">    <span class="comment">// this generates a separate chunk (about.[hash].js) for this route</span></span><br><span class="line">    <span class="comment">// which is lazy-loaded when the route is visited.</span></span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/About.vue'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//添加map的路由</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/map'</span>,</span><br><span class="line">    name: <span class="string">'mapView'</span>,</span><br><span class="line">    component: <span class="built_in">Map</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这时候，不出意外你可以在vue项目主页下就可以看到map的入口链接了。点击后会看到一个空白的Leaflet的地图容器。</p>
<img src="/2019/11/04/LeafletWithVue/微信截图_20191104105639.png" alt="微信截图_20191104105639" style="zoom:80%;">

<p>下面就是在这个容器中加载具体的地图。现在开源地图用的最多的应该是Open Street Map了，这里也以它来举例。</p>
<p>先在map.js中补充如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'leaflet/dist/leaflet.css'</span></span><br><span class="line"><span class="keyword">import</span> L <span class="keyword">from</span> <span class="string">'leaflet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMap = <span class="function">(<span class="params">divId, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> map = L.map(divId, options)</span><br><span class="line">    <span class="keyword">return</span> map</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加创建地图的函数</span></span><br><span class="line"><span class="keyword">const</span> createTileLayer = <span class="function">(<span class="params">map, url, options</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tileLayer = L.tileLayer(url, options)</span><br><span class="line">    tileLayer.addTo(map)</span><br><span class="line">    <span class="keyword">return</span> tileLayer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    createMap,</span><br><span class="line">    createTileLayer,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改map.vue如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"map-container"</span> id=<span class="string">"map-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: "mapView",</span></span><br><span class="line"><span class="regexp">  components: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      map: null,</span></span><br><span class="line"><span class="regexp">      OSMUrl: "https:/</span><span class="regexp">/&#123;s&#125;.tile.openstreetmap.org/</span>&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  mounted() &#123;</span></span><br><span class="line"><span class="string">    this.map = this.$utils.map.createMap("</span>map-container<span class="string">");</span></span><br><span class="line"><span class="string">    // 设施地图视图 中心位置</span></span><br><span class="line"><span class="string">    this.map.setView([34.03, -118.15], 13);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 加载 open street map和mapbox 图层服务</span></span><br><span class="line"><span class="string">   this.$utils.map.createTileLayer(this.map, this.OSMUrl, &#123;maxZoom: 19&#125;);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;style lang="</span>less<span class="string">"&gt;</span></span><br><span class="line"><span class="string">.map-container &#123;</span></span><br><span class="line"><span class="string">  position: absolute;</span></span><br><span class="line"><span class="string">  left: 0;</span></span><br><span class="line"><span class="string">  top: 100px; //添加100px间距，把上面的导航栏让出来</span></span><br><span class="line"><span class="string">  width: 100%;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>改完之后，地图容器里应该已经显示出 open street map 的地图了。</p>
<img src="/2019/11/04/LeafletWithVue/微信截图_20191104110840.png" alt="微信截图_20191104110840" style="zoom:80%;">

<p>以上就是简单的在Vue中使用Leaflet的方法，感谢阅读，希望能对大家有一点微小的帮助。欢迎评论和交流。</p>
<p>后面会补充一下Leaflet常见插件的使用教程，下一期先更一个Leaflet-side-by-side吧，效果大概长这样子：</p>
<p><img src="/2019/11/04/LeafletWithVue/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191104111358.png" alt="微信截图_20191104111358"></p>
<p>Leaflet-side-by-side示例网址点<a href="http://lab.digital-democracy.org/leaflet-side-by-side/" target="_blank" rel="noopener">这里</a></p>
<p>再次感谢！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>leaflet</tag>
      </tags>
  </entry>
  <entry>
    <title>Python接收UDP组播</title>
    <url>/2019/11/02/PythonUDPReceiver/</url>
    <content><![CDATA[<p>UDP 全称 <em>User Datagram Protocol（ 用户数据报协议 ）</em>，是 Internet 的传输层两个主要协议之一，相对于另外一个协议TCP而言，UDP是一种无需建立连接就可以发送封装的 IP 数据包的方法，但不是完全可靠的，丢包什么的都不管，在牺牲一定传输完整性保障的基础上，保证了传输性能；</p>
<p>UDP 组播是其发送数据的方法之一，特点就是发送端可以将消息发送到特定播组内，接收端只要处于该播组就可以接收到该消息；</p>
<p><strong>那么用Python编程时，应该怎么接入UDP的组播呢？</strong> </p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">multi_cast_group = <span class="string">'233.255.255.100'</span> <span class="comment"># 播组</span></span><br><span class="line">server_address = (<span class="string">''</span>, <span class="number">6001</span>) <span class="comment"># 播组端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the socket</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) <span class="comment"># 告诉socket是UDP</span></span><br><span class="line">sock.setblocking(<span class="literal">False</span>) <span class="comment"># 这里主要目的是防止拥塞的，后面会简要说明</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind to the server address</span></span><br><span class="line">sock.bind(server_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Tell the operating system to add the socket to the multi_cast group on all interfaces.</span></span><br><span class="line">group = socket.inet_aton(multi_cast_group)</span><br><span class="line">m_req = struct.pack(<span class="string">'4sL'</span>, group, socket.INADDR_ANY)</span><br><span class="line">sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, m_req)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Receive/respond loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data, address = sock.recvfrom(<span class="number">65535</span>) <span class="comment"># socket的recvfrom()会返回数据以及相应的地址</span></span><br><span class="line">        print(<span class="string">'received &#123;&#125; bytes from &#123;&#125;'</span>.format(len(data), address))</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError: </span><br><span class="line">        <span class="comment"># 因为某些特殊原因，这里略去了先判断时间的过程，源码里是做了一个判断，如果24小时内未收到消息，则执行下面的语句</span></span><br><span class="line">        print(<span class="string">'温馨提示： 24小时内未收到消息，请知悉并确认'</span>)</span><br></pre></td></tr></table></figure>

<p>上述代码结合注释应该比较清楚了，另外有几点简单说明一下：</p>
<ol>
<li>关于 setblocking 为false，其实是为了满足后面的另外一个需求：如果一定时间段内（比如24小时内）一直收不到UDP组播消息，也需要在微信或者钉钉提示一下，也是为了确认到底是没有UDP组播消息，还是该推送程序本身除了问题。</li>
<li>在实际测试中发现，在最后的while True循环中，如果不设置setblocking为false，那么就会发生拥塞，即  <code>data, address = sock.recvfrom(65535)</code> 这一语句持续执行，后面的语句无法执行。</li>
<li>解决办法就是用try，同时捕捉 BlockingIOError ，这样就可以在接收不到消息的时候执行其它操作了。</li>
</ol>
<p>以上基本就是Python编程接收UDP组播消息的方法，由于一些特殊原因，中间略去了部分内容，可能会一定程度上影响阅读，还望见谅。</p>
<p>有相关问题欢迎在评论区留言讨论，本人也是菜鸟，有说的不对的，还请大佬们多指教。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>UDP组播</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Earth Engine research</title>
    <url>/2019/10/14/geeresearch/</url>
    <content><![CDATA[<p>目前，超级计算机和高性能计算系统逐渐性能过剩，大量级的云计算以商品的形式变得触手可及。与此同时，来自NASA、 U.S. Geological Survey 和NOAA等多个美国政府机构和European Space Agency的PB级别存档遥感数据已免费对外提供，相应的地理信息数据大量级处理技术（如TerraLib、Hadoop、GeoSpark和GeoMesa）也日臻成熟。但是要充分利用这些海量数据资源仍然有相当高的技术要求。其中一个主要障碍就是基础的IT管理：数据的获取和存储；解析模糊文件格式；管理数据库、机器分布、任务及队列、CPUs、GPU、网络；地理信息数据处理框架等等；这就导致了很多研究者难以触及这些大数据处理工具，从而限制了研究人员对于海量遥感数据的研究。</p>
<a id="more"></a>

<p>针对以上问题，Google Earth Engine（GEE）应运而生。由谷歌、卡内基梅隆大学和美国地质调查局联合开发的GEE是目前世界上先进的PB级地理数据科学分析及可视化平台。GEE面向用户提供海量卫星影像数据集与地理数据集，包括40多年历史卫星影像数据与欧空局的卫星影像数据。同时，GEE提供基于JavaScript和Python语言的API接口、分析算法与工具，方便用户实现大型数据的处理分析与信息挖掘。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Google Earth Engine提供了多个类别PB级的可供分析的数据以及高性能并行计算服务，二者均可通过API获取及控制，并且GEE集成了基于Web的IDE（Interactive Development Environment）使得快速原型实现和结果可视化成为可能。</p>
<p>Google Earth Engine的数据库保存了大量的公共地理信息数据，包括各类卫星、航拍得到的光学和非光学波长的观测数据、环境变化、天气和气候的预报及后判、地形数据、社会经济学数据等等。所有这些数据都是经过一定预处理且保证不丢失相关信息的可直接使用形式（ready-to-use but information-preserving）。</p>
<p>用户可以使用和分析来自公共目录下的数据，也可以通过API调用数据库操作器来添加自己的私人数据库。该操作器是集成到大型并行处理系统的，能够自动划分算力，提供高通量的分析能力。用户既可以通过一个体量很小的Client Library，也可以通过在该Client Library基础上构建的交互开发环境来直接调用这些API。</p>
<img src="/2019/10/14/geeresearch/IDE.jpg" alt="Google earth engine编程交互界面" style="zoom:80%;">

<h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><p>Google Earth Engine公共数据目录是一个多维度PB级地理信息数据集。主要包括来自Landsat、Sentinel-1、Sentinel-2的地球观测遥感完整存档数据，以及诸如气候、地表覆盖数据等其他环境、地理信息和社会经济学数据（如表 1所示）。数据量还在以每天近6000 scenes（时延约24小时）的速度持续增加和更新。用户可以直接使用这些公共目录下的数据，也可以通过REST交互界面上传自己的私人数据且可以自由选择是否共享给他人。</p>
<center>Google earth engine 常用数据目录</center>


<table>
<thead>
<tr>
<th><strong>Dataset</strong></th>
<th><strong>Nominal   resolution</strong></th>
<th align="center"><strong>Temporal   granularity</strong></th>
<th><strong>Temporal   coverage</strong></th>
<th><strong>Spatial   coverage</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Landsat</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Landsat  8 OLI/TIRS</strong></td>
<td>30 m</td>
<td align="center">16 day</td>
<td>2013–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>Landsat  7 ETM +</strong></td>
<td>30 m</td>
<td align="center">16 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>Landsat  5 TM</strong></td>
<td>30 m</td>
<td align="center">16 day</td>
<td>1984–2012</td>
<td>Global</td>
</tr>
<tr>
<td><strong>Landsat  4–8 surface reflectance</strong></td>
<td>30 m</td>
<td align="center">16 day</td>
<td>1984–Now</td>
<td>Global</td>
</tr>
<tr>
<td>Sentinel</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Sentinel  1 A/B ground range detected</strong></td>
<td>10 m</td>
<td align="center">6 day</td>
<td>2014–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>Sentinel  2A MSI</strong></td>
<td>10/20 m</td>
<td align="center">10 day</td>
<td>2015–Now</td>
<td>Global</td>
</tr>
<tr>
<td>MODIS</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>MOD08  atmosphere</strong></td>
<td>1°</td>
<td align="center">Daily</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD09  surface reflectance</strong></td>
<td>500 m</td>
<td align="center">1 day/8 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD10  snow cover</strong></td>
<td>500 m</td>
<td align="center">1 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD11  temperature and emissivity</strong></td>
<td>1000 m</td>
<td align="center">1 day/8 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MCD12  Land cover</strong></td>
<td>500 m</td>
<td align="center">Annual</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD13  Vegetation indices</strong></td>
<td>500/250 m</td>
<td align="center">16 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD14  Thermal anomalies &amp; fire</strong></td>
<td>1000 m</td>
<td align="center">8 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MCD15  Leaf area index/FPAR</strong></td>
<td>500 m</td>
<td align="center">4 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD17  Gross primary productivity</strong></td>
<td>500 m</td>
<td align="center">8 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MCD43  BRDF-adjusted reflectance</strong></td>
<td>1000/500 m</td>
<td align="center">8 day/16 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MOD44  veg. cover conversion</strong></td>
<td>250 m</td>
<td align="center">Annual</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>MCD45  thermal anomalies and fire</strong></td>
<td>500 m</td>
<td align="center">30 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td>ASTER</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>L1 T  radiance</strong></td>
<td>15/30/90 m</td>
<td align="center">1 day</td>
<td>2000–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>Global  emissivity</strong></td>
<td>100 m</td>
<td align="center">Once</td>
<td>2000–2010</td>
<td>Global</td>
</tr>
<tr>
<td>Other imagery</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>PROBA-V  top of canopy reflectance</strong></td>
<td>100/300 m</td>
<td align="center">2 day</td>
<td>2013–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>EO-1  hyperion hyperspectral radiance</strong></td>
<td>30 m</td>
<td align="center">Targeted</td>
<td>2001–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>DMSP-OLS  nighttime lights</strong></td>
<td>1 km</td>
<td align="center">Annual</td>
<td>1992–2013</td>
<td>Global</td>
</tr>
<tr>
<td><strong>USDA NAIP  aerial imagery</strong></td>
<td>1 m</td>
<td align="center">Sub-annual</td>
<td>2003–2015</td>
<td>CONUS</td>
</tr>
<tr>
<td>Topography</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Shuttle  Radar Topography Mission</strong></td>
<td>30 m</td>
<td align="center">Single</td>
<td>2000</td>
<td>60°N–54°S</td>
</tr>
<tr>
<td><strong>USGS  National Elevation Dataset</strong></td>
<td>10 m</td>
<td align="center">Single</td>
<td>Multiple</td>
<td>United States</td>
</tr>
<tr>
<td><strong>USGS  GMTED2010</strong></td>
<td>7.5″</td>
<td align="center">Single</td>
<td>Multiple</td>
<td>83°N–57°S</td>
</tr>
<tr>
<td><strong>GTOPO30</strong></td>
<td>30″</td>
<td align="center">Single</td>
<td>Multiple</td>
<td>Global</td>
</tr>
<tr>
<td><strong>ETOPO1</strong></td>
<td>1′</td>
<td align="center">Single</td>
<td>Multiple</td>
<td>Global</td>
</tr>
<tr>
<td>Landcover</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>GlobCover</strong></td>
<td>300 m</td>
<td align="center">Non-periodic</td>
<td>2009</td>
<td>90°N–65°S</td>
</tr>
<tr>
<td><strong>USGS  National Landcover Database</strong></td>
<td>30 m</td>
<td align="center">Non-periodic</td>
<td>1992–2011</td>
<td>CONUS</td>
</tr>
<tr>
<td><strong>UMD  global forest change</strong></td>
<td>30 m</td>
<td align="center">Annual</td>
<td>2000–2014</td>
<td>80°N–57°S</td>
</tr>
<tr>
<td><strong>JRC  global surface water</strong></td>
<td>30 m</td>
<td align="center">Monthly</td>
<td>1984–2015</td>
<td>78°N–60°S</td>
</tr>
<tr>
<td><strong>GLCF  tree cover</strong></td>
<td>30 m</td>
<td align="center">5 year</td>
<td>2000–2010</td>
<td>Global</td>
</tr>
<tr>
<td><strong>USDA  NASS cropland data layer</strong></td>
<td>30 m</td>
<td align="center">Annual</td>
<td>1997–2015</td>
<td>CONUS</td>
</tr>
<tr>
<td>Weather,  precipitation &amp; atmosphere</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Global  precipitation measurement</strong></td>
<td>6′</td>
<td align="center">3 h</td>
<td>2014–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>TRMM  3B42 precipitation</strong></td>
<td>15′</td>
<td align="center">3 h</td>
<td>1998–2015</td>
<td>50°N–50°S</td>
</tr>
<tr>
<td><strong>CHIRPS  precipitation</strong></td>
<td>3′</td>
<td align="center">5 day</td>
<td>1981–Now</td>
<td>50°N–50°S</td>
</tr>
<tr>
<td><strong>NLDAS-2</strong></td>
<td>7.5′</td>
<td align="center">1 h</td>
<td>1979–Now</td>
<td>North America</td>
</tr>
<tr>
<td><strong>GLDAS-2</strong></td>
<td>15′</td>
<td align="center">3 h</td>
<td>1948–2010</td>
<td>Global</td>
</tr>
<tr>
<td><strong>NCEP  reanalysis</strong></td>
<td>2.5°</td>
<td align="center">6 h</td>
<td>1948–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>ORNL  DAYMET weather</strong></td>
<td>1 km</td>
<td align="center">Annual</td>
<td>1980–Now</td>
<td>North America</td>
</tr>
<tr>
<td><strong>GRIDMET</strong></td>
<td>4 km</td>
<td align="center">1 day</td>
<td>1979–Now</td>
<td>CONUS</td>
</tr>
<tr>
<td><strong>NCEP  global forecast system</strong></td>
<td>15′</td>
<td align="center">6 h</td>
<td>2015–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>NCEP  climate forecast system</strong></td>
<td>12′</td>
<td align="center">6 h</td>
<td>1979–Now</td>
<td>Global</td>
</tr>
<tr>
<td><strong>WorldClim</strong></td>
<td>30″</td>
<td align="center">12 images</td>
<td>1960–1990</td>
<td>Global</td>
</tr>
<tr>
<td><strong>NEX  downscaled climate projections</strong></td>
<td>1 km</td>
<td align="center">1 day</td>
<td>1950–2099</td>
<td>North America</td>
</tr>
<tr>
<td>Population</td>
<td></td>
<td align="center"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>WorldPop</strong></td>
<td>100 m</td>
<td align="center">5 year</td>
<td>Multiple</td>
<td>2010–2015</td>
</tr>
<tr>
<td><strong>GPWv4</strong></td>
<td>30″</td>
<td align="center">5 year</td>
<td>2000–2020</td>
<td>85°N–60°S</td>
</tr>
</tbody></table>
<p>Earth Engine运行在一个轻量级的“图像”容器中，使用基于2D网络栅格波段的简单且高度通用的数据模型。单一谱段的像素点需在数据类型、分辨率和投影上保持一致，但是图像可以包含任意数量的谱段且一幅图中的谱段不需要有统一的数据类型和投影。每幅图也具有相关键值对的元数据来存储诸如图像的拍摄位置、拍摄时间和条件等信息。</p>
<p>相关的图像，比如同一个Sensor产出的数据分成一组，构成一个数据集。数据集的高速筛选和分类能力使得用户可以轻松地在数以百万计的图像中搜索和选择满足特定区域、时间和其他标准的数据。</p>
<p>导入Earth Engine的数据都会经过预处理以达到快速并有效查询使用的目标。</p>
<p>首先，图片按照原有的投射和分辨率切成瓦片存储到高效且备份的瓦片数据库中。每幅瓦片尺寸为256×256，这是在载入不需要的数据和预加载额外请求数据之间采取的折衷方案。与传统的“data cube”系统不同，这种数据摄入处理能够做到不丢失数据信息：数据仍然保持其原有的投影、分辨率和bit位，从而避免了数据在重采样到一个固定网格下而产生解构导致可能会不适用于特定的应用。</p>
<p>另外，为了在计算开发过程中能够快速可视化，每幅图都会对应有降低分辨率的瓦片图组成的金字塔模型存储在对应瓦片图数据库中。金字塔中的每一层都是通过对上一层以1/2的比例进行缩减像素采样（向下采样）得来的。在向下采样时，连续值谱段通常采取平均采样模式，而对离散值谱段（例如分类标签）使用最小、模式化、最大或固定采样模式中的一种进行采样。当只需要一幅图的一部分数据在降低分辨率下计算时，只有最合适的金字塔层级下相关的瓦片图才会从数据库中被调取出来供使用。这种指数级缩量方式使得数据能够在不同量级都能够使用而又不用耗费大量的存储，同时也能够满足基于web的地图展示。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>Earth Engine是建立在Google data center环境下的一系列技术基础之上的。其中包括Borg集群管理系统、Bigtable、Spanner分布式数据库、Colossus（Google File System的接班者）以及用于并行管道计算的FlumeJava框架。另外，Earth Engine还可以与Google Fusion Tables（一种基于web的数据库，支持带有属性的点、线、多边形等几何类型的数据表）进行互操作。</p>
<img src="/2019/10/14/geeresearch/1571105424921.png" alt="1571105424921" style="zoom:80%;">

<p>Earth Engine的基本架构如图 所示。Code Editor和第三方Web Apps可以借助客户端库通过Web REST API来向系统发送交互或批量请求。即时请求通过Front End servers进行处理并向Compute Master发送下一级请求。Compute Master则负责在Compute Servers资源池中进行分布式计算的任务规划。Batch Computation的运行逻辑与此基本一致，只不过是通过FlumeJava框架来管理分布规划。支持这两个计算系统的是一系列的数据服务，包括Asset Database（存有每幅图的元数据并具有高效筛选能力）。前面提到的Borg集群管理软件则负责管理系统的每个组件和每项服务在多用户之间的负载均衡。任何单一用户的请求失败只会导致重新发起查询请求而不会对系统造成其他影响。</p>
<p>向Earth Engie发送的请求是基于功能进行整合和求解的。用户通过从Earth Engine 的800多个函数中选取自己需要的组合起来构建自己的数据或数据处理请求，这里面既有用于地理信息处理的简繁不等的数学函数，又有机器学习、图像处理等相关的操作函数。这个算法库使得用户可以通过图像代数方法很轻松地处理图像数据，并且支持高阶的函数比如：map（）和iterate（）（二者均支持对一系列图像应用随机函数）、reduce（）（用来计算按照区域、滑窗、时域、光谱或其他形式组织的统计数据）。下表总结了在客户端库中包含的各种类型的函数和算法。</p>
<table>
<thead>
<tr>
<th align="left"><strong>Function category</strong></th>
<th><strong>Examples</strong></th>
<th align="left"><strong>Mode of operation</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Numerical operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Primitive operations</strong></td>
<td>add, subtract, multiply, divide, <em>etc.</em></td>
<td align="left">Per pixel/per feature</td>
</tr>
<tr>
<td align="left"><strong>Trigonometric operations</strong></td>
<td>cos, sin, tan, acos, asin, atan, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Standard functions</strong></td>
<td>abs, pow, sqrt, exp., log, erf, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Logical operations</strong></td>
<td>eq, neq, gt, gte, lt, lte, and, or</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Bit/bitwise operations</strong></td>
<td>and, or, xor, not, bit shift, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Numeric casting</strong></td>
<td>int, float, double, uint8, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Array/matrix operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Elementwise operations</strong></td>
<td>(numeric operations as above)</td>
<td align="left">Per pixel/per feature</td>
</tr>
<tr>
<td align="left"><strong>Array manipulation</strong></td>
<td>Get, length, cat, slice, sort, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Array construction</strong></td>
<td>Identity, diagonal, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Matrix operations</strong></td>
<td>Product, determinant, transpose, inverse, pseudoinverse,  decomposition, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Reduce and accumulate</strong></td>
<td>Reduce, accum</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Machine learning</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Supervised classification and regression</strong></td>
<td>Bayes, CART, Random Forest, SVM, Perceptron, Mahalanobis, <em>etc.</em></td>
<td align="left">Per pixel/per feature</td>
</tr>
<tr>
<td align="left"><strong>Unsupervised Classification</strong></td>
<td>K-Means, LVQ, Cobweb, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Other per-pixel image operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Spectral operations</strong></td>
<td>Unmixing, HSV transform, <em>etc.</em></td>
<td align="left">Per pixel</td>
</tr>
<tr>
<td align="left"><strong>Data masking</strong></td>
<td>Unmask, update mask, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Visualization</strong></td>
<td>Min/max, color palette, gamma, SLD, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Location</strong></td>
<td>Pixel area, pixel coordinates, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Kernel operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Convolution</strong></td>
<td>Convolve, blur, <em>etc.</em></td>
<td align="left">Per image tile</td>
</tr>
<tr>
<td align="left"><strong>Morphology</strong></td>
<td>Min, max, mean, distance, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Texture</strong></td>
<td>Entropy, GLCM, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Simple shape kernels</strong></td>
<td>Circle, rectangle, diamond, cross, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Standard kernels</strong></td>
<td>Gaussian, Laplacian, Roberts, Sobel, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Other kernels</strong></td>
<td>Euclidean, Manhattan and Chebyshev distance, arbitrary kernels and  combinations</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Other Image Operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Band manipulation</strong></td>
<td>Add, select, rename, <em>etc.</em></td>
<td align="left">Per image</td>
</tr>
<tr>
<td align="left"><strong>Metadata properties</strong></td>
<td>Get, set, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Derivative</strong></td>
<td>Pixel-space derivative, spatial gradient</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Edge detection</strong></td>
<td>Canny, Hough transform</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Terrain operations</strong></td>
<td>Slope, aspect, hillshade, fill minima, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Connected components</strong></td>
<td>Components, component size</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Image clipping</strong></td>
<td>Clip</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Resampling</strong></td>
<td>Bilinear, bicubic, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Warping</strong></td>
<td>Translate, changeProj</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Image registration</strong></td>
<td>Register, displacement, displace</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Other tile-based operations</strong></td>
<td>Cumulative cost, medial axis, reduce resolution with arbitrary  reducers, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Image aggregations</strong></td>
<td>Sample region(s), reduce region(s) with arbitrary reducers</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Reducers</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Simple</strong></td>
<td>Count, distinct, first, <em>etc.</em></td>
<td align="left">Context-dependent</td>
</tr>
<tr>
<td align="left"><strong>Mathematical</strong></td>
<td>sum, product, min, max, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Logical</strong></td>
<td>Logical and/or, bitwise and/or</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Statistical</strong></td>
<td>Mean, median, mode, percentile, standard deviation, covariance,  histogram, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Correlation</strong></td>
<td>Kendall, Spearman, Pearson, Sen’s slope</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Regression</strong></td>
<td>Linear regression, robust linear regression</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Geometry Operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Types</strong></td>
<td>Point, LineString, Polygon, <em>etc.</em></td>
<td align="left">Per-feature</td>
</tr>
<tr>
<td align="left"><strong>Measurements</strong></td>
<td>Length, area, perimeter, distance, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Constructive operations</strong></td>
<td>Intersection, union, difference, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Predicates</strong></td>
<td>Intersects, contains, withinDistance, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Other operations</strong></td>
<td>Buffer, centroid, transform, simplify, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Table/collection operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Basic manipulation</strong></td>
<td>Sort, merge, size, first, limit, distinct, flatten, remap, <em>etc.</em></td>
<td align="left">Streaming</td>
</tr>
<tr>
<td align="left"><strong>Property filtering</strong></td>
<td>eq, neq, gt, lt, date range, and, or, not, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Spatial filtering</strong></td>
<td>Intersects, contains, withinDistance, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Parallel processing</strong></td>
<td>Map, reduce, iterate</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Joins</strong></td>
<td>Simple, inner, grouping, <em>etc.</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Vector/raster operations</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Rasterization</strong></td>
<td>Paint/draw, distance</td>
<td align="left">Per tile</td>
</tr>
<tr>
<td align="left"><strong>Spatial interpolation</strong></td>
<td>Kriging, IDW interpolation</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Vectorization</strong></td>
<td>reduceToVectors</td>
<td align="left">Scatter/gather</td>
</tr>
<tr>
<td align="left">Other data types</td>
<td></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><strong>Number, string, list, dictionary, date, daterange,  projection, *etc.*</strong></td>
<td>Context-dependent</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>该库的基于图像的函数的大部分是对每个像素进行代数运算，在每个频段或频段之间的基础上运行，涵盖整数和浮点数学运算，逻辑比较，位操作，类型转换，条件替换和用于处理像素数组值化的多维数组操作。另外还包括常见的像素操纵函数，例如表查找，分段线性插值，多项式求解和普遍存在的归一化差异等。该库利用几个预制的机器学习工具包，可以轻松访问20多种类型的监督分类，回归和无监督集群，以及用于准确性求解的混淆矩阵操作。对于机器视觉任务，可以使用常见的基于内核的窗口操作，例如卷积，形态操作，距离和纹理分析，以及简单的基于邻域的操作，例如梯度，斜率，宽高比和连通性。其他功能还包括图像和波段元数据操作，投影和重采样操作，屏蔽和裁剪，图像到图像位移和配准以及遥感应用常用的各种专用工具，包括约束光谱分离，区域增长和成本映射操作等等。</p>
<p>用户可以组合这些库函数以构建希望执行的计算描述。该计算描述最终以有向非循环图（DAG）的形式呈现给Earth Engine，其中每个节点代表一个单一函数或数据访问器的执行，并包含命名函数参数的键/值对。实质上，这是一个纯函数式编程环境，而Earth Engine利用了函数式语言常用的标准技术，例如参考透明度和惰性求值，以实现显著的优化和效率提升。</p>
<p>用户使用客户端库（目前可用Python和JavaScript语言）编写Earth Engine程序，允许用户使用熟悉的程序式编程范式来描述如何处理图表。客户端库为图像、集合和其他数据类型（如数字，字符串，几何和列表）提供代理对象。用户脚本操纵这些代理对象，这些对象记录操作链并将它们组装成能够表达完整计算的DAG。然后将此DAG发送到Earth Engine服务进行求解。</p>
<p>DAG的求解是通过一系列的图表转换实现的。转换后的子图表如果可能的话会立即进行进一步求解来实现贪婪简化，从而避免冗余计算以及任何并行计算不可用的地方。比如，在子图表中表达式3+7会立即被简化成10这种值的形式。图中的其他节点会被扩展，例如当求解一个指向图像集合的节点时，它会被扩展为一个图像序列以便后续处理批量化执行。表示复杂处理操作的节点可以采用下一节中描述的分布式处理的几种策略中的任何一种。</p>
<p>Earth Engine旨在支持快速，交互式探索和分析空间数据，允许用户平移和缩放结果来每次查看图像的一个子集。为此，Earth Engine使用惰性计算模型，该模型仅允许计算满足当前请求所需的特定部分来进行输出。</p>
<p>举个例子，比如说用户可能希望计算两个季节合成图像之间的差异，进而突出显示由于气候或者积雪引起的变化情况。最简单的实现方式就是通过Earth Engine的客户端库拉取两个复合图像的差集。</p>
<img src="/2019/10/14/geeresearch/1571105566769.png" alt="Google earth engine code拉取复合图像差集" style="zoom:80%;">

<p>此代码创建了两个过滤的集合，其中一个是11月，12月和1月的所有Landsat 8图像，另一个是6月，7月和8月的所有Landsat 8图像。首先计算每个数据集中每个谱段的时域插值（目的是为了最小化云和云阴影的影响），然后减去所得到的复合图像结果来计算值的变化。该计算描述的DAG表示如图 所示。</p>
<img src="/2019/10/14/geeresearch/1571105584534.png" alt="Google Earth Engine DAG计算描述" style="zoom:80%;">

<p>传统（非惰性）计算环境可能会在处理表达式后立即开始计算一个或两个复合材料的像素，这通常需要提前将输入数据集预处理为公共地图投影，分辨率和感兴趣区域。</p>
<p>相反，Earth Engine采用了不同的方法：它推迟计算输出像素，知道它清楚了解到这些结果是在什么样的情况下是必须的。例如，如果结果当前显示在交互式地图上，则地图的缩放级别和视图边界可以动态地决定输出的投影和分辨率，并且可以将像素计算限制为仅可查看的像素。或者，如果结果当前要被用作另一计算的输入，则该计算可以请求所需像素的适当投影，分辨率和边界。此信息用于动态地自动重新采样和重新投影输入数据，从而可以快速可视化结果或在更复杂的计算中使用该表达式，而无需用户预先指定需要哪些像素。默认情况下，使用输入的最近邻重采样来对所请求的输出投影进行重新投影和重采样（从每个输入的下一个最高分辨率金字塔等级中选择像素），以保持频谱完整性。但是，当用户对如何管理这种重投影有偏好时，他们可以选择精确控制投影网格，并可以选择双线性和双三次采样模式。</p>
<p>这种方式更有助于采用交互模式和迭代模式来开展数据挖掘和算法开发。一旦用户完成算法的开发并想要大规模应用，他们可以向Earth Engine提交一个批处理请求来计算得到完整结果并在Earth Engine中实例化为一副图像或者是可供下载的多幅图像、表格甚至是视频文件。</p>
<h3 id="数据分布式处理模型"><a href="#数据分布式处理模型" class="headerlink" title="数据分布式处理模型"></a>数据分布式处理模型</h3><p>Earth Engine库中的功能使用多种内置并行化和数据分布模型来实现高性能。每种模型都针对不同的数据访问模式进行了优化。  </p>
<h4 id="图像瓦片处理"><a href="#图像瓦片处理" class="headerlink" title="图像瓦片处理"></a>图像瓦片处理</h4><p>在遥感中使用的许多光栅处理操作是局部的：任何特定输出像素的计算仅取决于某个固定距离内的输入像素。比如例如频带数学计算或频谱解混，以及诸如卷积或纹理分析的邻域操作等针对但像素的操作。通过将区域细分为区块并独立地计算每个区域，可以很容易地并行处理这些操作。处理每个输出图块通常需要为每个输入仅检索一个或少量图块。这与金字塔输入和合理的缓存相结合，可以在任何要求的比例或投影中快速计算结果。如前所述，输入会根据需要随时重新投影以匹配投影输出的需求。当然，如果用户确定不希望使用向下采样或重新投影输入，则可以在输入的投影和比例中明确指定计算方式。</p>
<p>大多数基于图块的操作都是使用两种策略中的一种在Earth Engine中实现的，具体取决于它们的计算成本。 针对成本较高的操作以及一次性计算整个瓦片具有显著优势的操作，会将结果写入瓦片尺寸相匹配的输出缓冲区。 瓦片通常为256×256像素，以匹配输入预处理的瓦片大小。</p>
<p>对于成本低的单像素运算，是通过在一个可直接相互调用的图表中执行图像处理的界面中按照每次一个像素来进行。这种结果目的是为了充分利用这些操作在Java虚拟机（JVM）环境中执行的优势，该环境具有即时（JIT）编译器，编译器负责提取并编译重复发生的函数调用序列。结果表明，在多数情况下，原始图像操作的任意链式操作都可以像手工编译的代码一样有效地执行。</p>
<h4 id="空间聚合"><a href="#空间聚合" class="headerlink" title="空间聚合"></a>空间聚合</h4><p>正如某些类别的计算本质上是局部的，其他类别本质上是非局部的，例如区域或全局统计的计算，光栅到矢量的转换，或者采样图像以训练分类器。 这些操作或它们的一部分通常仍然可以并行执行，但计算最终结果需要将许多子结果聚合在一起。 例如，计算整个图像的平均值可以通过细分图像，在每个部分上并行计算和计数，然后对这些部分和计数求和来得到所需结果。</p>
<p>在Earth Engine中，这些类型的计算使用分散-聚集模型作为分布式进程执行。需要执行聚合的空间区域会被划分为子区域分配给分布式算力资源池中的算力单元以便进行批量求解。 每个算力单元获取或计算所需的输入像素，然后运行所需的累积操作以计算其部分结果。 这些结果将被发送回主计算器进行此计算，该计算将它们组合并将结果转换为最终形式。 例如，当计算平均值时，每个算力单元将计算总和与计数，主运算收集并汇总这些中间结果，并以总和除以总计数得到最终计算结果。</p>
<h4 id="流式聚合"><a href="#流式聚合" class="headerlink" title="流式聚合"></a>流式聚合</h4><p>处理大型遥感数据集的另一个常见操作是时间序列分析。应用在空间上的相同统计聚合操作也可以应用于计算整个图像堆栈中随着时间变化的像素级变化情况。 这些操作都是通过瓦片组合来实现的。以前述方式使用延迟图像求解并行计算得到每个瓦片的输出。在每个瓦片图内，针对每个像素都会执行聚合操作。来自输入图像集合的像素数据是批量请求的，并且通过单像素聚合器进行一次性“流式传输”。 与输出瓦片相交的所有输入处理完成后，就会在每个像素处都应用最终转换以生成输出结果。</p>
<p>对于具有小中间状态的聚合（比如计算最小值），该分布模型可以做到快速且有效。但是对于不具有中间状态的聚合来说，可能就会非常耗费内存（比如计算Pearson的相关性，就需要在计算最终结果之前在每个像素上都存储完整的数据序列）。不过，只要瓦片的大小是明显小于完整图像的，那么即使是非常大的数据集合，流式传输仍然可以做到非常快。例如，对于Lansat5、7、8的完整数据集堆栈，包含超过500万张图片，在任意一点都只有少于2000张瓦片的深度，平均来看其实只有500张的深度。</p>
<h4 id="缓存以及常见的子表达式消除"><a href="#缓存以及常见的子表达式消除" class="headerlink" title="缓存以及常见的子表达式消除"></a>缓存以及常见的子表达式消除</h4><p>Earth Engine中的许多处理操作的成本和数据密集度都非常高，因此避免冗余计算将回事非常有价值的。例如，在地图上查看结果的单个用户将触发对输出区块的多个独立请求，所有输出区块经常依赖于一个或多个公共的子表达式，例如大空间聚合或监督分类器的训练等。为了避免重新计算先前已经请求的值，使用子图的散列作为高速缓存键将成本较高的的中间结果存储在分布式的高速缓存中。虽然多个用户可能共享缓存中的项目，但两个独立用户独立地进行相同查询的情况并不常见。但是，单个用户在增量算法开发期间重复相同的查询并因此受益于这种缓存机制就是非常常见的了。在单个查询的分布式执行期间，高速缓存还用作共享存储器的形式，存储对应于查询的子图的中间结果。</p>
<p>当对相同计算的后续请求到达时，较早的计算可能已经完成或者仍可能正在进行中。在开始成本高昂的操作之前，会优先去检索缓存并返回之前计算的结果。为了处理早期计算仍在进行中的情况，所有计算都是通过少量计算主服务器发送给分布式算力单元的。这些服务器会在任何给定时刻跟踪群集中正在执行的计算。当新查询到达时，如果它依赖于某些正在进行的计算，该查询将会直接加入原始查询序列中去以等待计算完成。如果计算主机出现失败，则正在进行的计算的处理可能会丢失，这种情况下可能会允许启动冗余计算，但前提是在现有计算任务完成之前就重新请求查询。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>Earth Engine正广泛应用于各个领域，涵盖全球森林变化，全球地表水变化、作物产量估算、稻田制图、城市测绘、洪水测绘、火灾恢复和疟疾风险绘图等等不同主题。它还被整合到许多第三方应用中，例如分析物种栖息地范围（Map of Life）、监测气候（Climate Engine）和评估土地利用变化（Collect Earth）等等。Google Earth Engine从项目创立至今，主要面向的用户为世界各地与地理信息研究相关的院校、研究机构和科研人员。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Google earth engine</tag>
      </tags>
  </entry>
</search>
